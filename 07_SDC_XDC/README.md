# Конспект знаний по SDC и  XDC

## SDC

###  Конспект :
1. clk

   1. Start with Clock Period and Duty Cycle
         1. Clock period (a.k.a cycle-time )
         2. Duty Cycle = ratio = pulse width high time / pulse width low time

   2. create_clock
          1. create_clock –name “PHI1” –period 10 –waveform {0.0 5.0} [get_ports clk]

                * Создаёт такт "PHI1" с периодом 10 нс
                * Форма: подъём на 0.0 нс, спад на 5.0 нс (50% duty cycle)
                * Источник - порт clk (вероятно, входной порт чипа)
          2. create_clock -name "clk" -period 4 -waveform {2.0 4.0} {clkg1/Z clkg2/Z clkg3/Z}
                * Создаёт тактовый сигнал с именем "clk" и периодом 4 нс
                * Форма сигнала (waveform): подъём на 2.0 нс, спад на 4.0 нс (т.е. duty cycle 50%)
                * Источники тактового сигнала - выходы (Z) трёх буферов clkg1, clkg2, clkg3
          3. create_clock –name "clk10" –period 10 –waveform {0.0 9.0} [get_pins U1/clkout]
                * Создаёт такт "clk10" с периодом 10 нс
                * Форма: подъём на 0.0 нс, спад на 9.0 нс (очень несимметричный, 90% duty cycle)
                * Источник - выходной пин clkout элемента U1



    3. `Clock Insertion Delay` (a.k.a. clock latency)


        |Флаг	    |Что означает                                                   |
        |-----------|---------------------------------------------------------------|
        |-source    |	Это задержка от источника (PLL, порт) до начала clock tree  |
        |без -source|	Это задержка по clock tree до регистра                      |
        |-early     |	Используется в hold анализе (ранний приход такта)           |
        |-late      |	Используется в setup анализе (поздний приход такта)         |
        |-rise      |	Применяется только к фронту (rising edge)                   |
        |-fall      |	Применяется только к спаду (falling edge)                   |


   4. `Source Latency` (Источник задержки)
            Это задержка от внешнего источника (например, порт clk или PLL) до входа в чип
            или до корня дерева тактовой сети внутри чипа.
            SDC-команда:

            ```tcl
            set_clock_latency -source <value> [get_clocks <clock_name>]
            ```

            Пример:

            ```tcl
            set_clock_latency -source 1.2 [get_clocks clk]

            ```

            Это значит, что сигнал clk доходит до начала clock tree за 1.2 нс.

        1. `Network Latency` (Clock Network Delay / Clock Tree Delay)

            Это задержка от корня clock tree до регистра внутри чипа,
            то есть сколько времени нужно, чтобы сигнал прошёл по clock tree (буферы, маршруты и т.д.).

            ```tcl
            set_clock_latency <value> [get_clocks <clock_name>]
            ```

            Пример:

            ```tcl
            set_clock_latency 0.8 [get_clocks clk]

            ```

            Значит, что от начала clock tree до регистра — 0.8 нс.

        2. `-rise / -fall`

            ``` TCL
            set_clock_latency 1.2 -rise [get_clocks CLK1]
            set_clock_latency 0.9 -fall [get_clocks CLK1]

            ```

            Устанавливает clock network latency (внутри кристалла):

            * 1.2 нс до фронта сигнала (rising edge)
            * 0.9 нс до спада сигнала (falling edge)
            * Эти значения используются в анализе тайминга, чтобы определить реальное время, когда тактовый импульс доходит до регистра.

            ```tcl
            set_clock_latency 0.8 -source -early [get_clocks CLK1]
            set_clock_latency 0.9 -source -late [get_clocks CLK1]

            ```
            Задаёт source latency — задержку от генератора сигнала (например, PLL) до начала clock tree.

            * -source: это именно source latency, а не задержка по clock tree.
            * -early и -late:
            * -early используется в hold анализе (самый ранний приход сигнала)
            * -late используется в setup анализе (самый поздний приход сигнала)

        3. Задержки влияют на расчёт setup/hold таймингов. Они определяют, когда реально приходит такт на регистр, 
        и как сравнивать это с сигналами данных.

    5. Clock Uncertainty — это временной интервал, который учитывает
       1. джиттер (jitter) — нестабильность генерации (например, у PLL)
       2. неидеальность распространения по clock tree — сигнал может прийти к разным флип-флопам в немного разное время
       3. интерклоковая неопределённость (inter-clock skew/jitter) — между разными тактовыми доменами

                Команда: set_clock_uncertainty

            ```tcl
            set_clock_uncertainty -setup 0.65 [get_clocks CLK]
            set_clock_uncertainty -hold  0.45 [get_clocks CLK]

            ```
            *-setup: уменьшает время для setup анализа (усложняет тайминг)
            *-hold: увеличивает время для hold анализа (также усложняет тайминг)
            *-from / -to: можно указать конкретные тактовые домены (для междоменной неопределённости)

            Таким образом:

            * setup становится жёстче: данные должны прийти раньше.
            * hold становится тоже жёстче: данные не должны меняться слишком рано.

    6. Создание производного клока: `create_generated_clock`

        Для моделирования делителей/умножителей частоты, синхронных с основным клоком:

        ```tcl
        create_generated_clock -source FF1/CP -divide_by 2 -name CLK-OUT [get_pins FF1/Q]

        ```

        Пояснение:

        * -source FF1/CP: мастер-клок на входе CP регистра FF1
        * -divide_by 2: выходной клок будет в 2 раза медленнее
        * [get_pins FF1/Q]: создаётся на выходном пине Q регистра

        Пояснение параметров `create_generated_clock`

        | Параметр	        |Описание                                                       |
        |-------------------|---------------------------------------------------------------|
        |-source	        |Указывает мастер-клок (пин, откуда берётся исходный клок)      |
        |-divide_by N	    |Делит частоту клока на N                                       |
        |-multiply_by N	    |Умножает частоту клока на N                                    |
        |-duty_cycle %	    |Скважность сигнала в процентах                                 |
        |-edges	            |Явно задаёт фронты мастер-клока, формирующие новый клок        |
        |-invert	        |Инвертирует фазу клока                                         |
        |-edge_shift	    |Смещает фронты                                                 |


    7. `set_clock_transition`
       1. Эта команда задаёт скорость нарастания/спада фронтов клока (slew rate), то есть время перехода от 0 до 1 (и наоборот).

            * Работает только для ideal clocks
            * Не влияет на propagated clocks — для них переходы считаются по цепям
            * Если не указать set_clock_transition, то инструмент сам придумает переход (не всегда точный)
            * Помогает избежать заниженной/завышенной оценки тайминга

        Пример:

        ```tcl
        set_clock_transition 0.38 -rise [get_clocks CLK1]
        set_clock_transition 0.25 -fall [get_clocks CLK1]

        ```

        * Означает:

        * Время подъёма фронта (rise time) клока = 0.38 нс
        * Время спада фронта (fall time) клока = 0.25 нс
        * Применяется к клоку с именем CLK1
2. delay
    1. Input
        1. `set_input_delay – 1/2`

             1. Один тактовый домен

                 ```tcl
                 set_input_delay 4.3 -rise -clock CK2 {IN2}
                 set_input_delay 3.5 -fall -clock CK2 {IN2}

                 ```
                 IN2 — входной порт.
                 CK2 — тактовый сигнал с периодом 8 нс.
                 Сигнал IN2 может:
                 подняться (rising edge) через 4.3 нс после фронта CK2.
                 упасть (falling edge) через 3.5 нс после фронта CK2.

             2. Мультиклоковая задержка с -add_delay

                 ```tcl
                 set_input_delay 2.7 -clock CK1 -add_delay {IN1}
                 set_input_delay 4.2 -clock CK2 -add_delay {IN1}

                 ```

                 Вход IN1 может приходить от двух разных доменов: CK1 и CK2.
                 -add_delay указывает, что обе задержки добавляются, формируя связь между тактами.
                  Используется в асинхронных или мультиклоковых интерфейсах для описания перекрестных задержек.

        2. `set_input_delay – 2/2`

            Внешний модуль, генерирующий данные

            ```tcl
            set_input_delay 17 -rise -clock clk {d1}

            ```
            Внешний модуль (другой блок/микросхема) подаёт сигнал d1 через 17 нс после фронта clk.
            Эта задержка указывает, когда сигнал реально появится в текущем проекте, чтобы его можно было корректно захватить.
        3. Пояснение параметров

            | Параметр                    | Описание                                                   |
            | --------------------------- | ---------------------------------------------------------- |
            | -clock <clk>              | Указывает, к какому такту относится задержка               |
            | -rise / -fall           | Задержка для переднего или заднего фронта данных           |
            | -add_delay                | Учитывать дополнительные задержки между тактовыми доменами |
            | -max / -min             | Задержки для worst-case / best-case анализа                |
            | -network_latency_included | Учитывать ли задержку проводников                          |
            | -source_latency_included  | Учитывать ли задержку источника сигнала                    |




    1. `set_output_delay`
        Назначение

            * Указывает, сколько времени у вашего проекта есть, чтобы передать данные на внешний модуль.
            * То есть внешний модуль будет ожидать данные через указанное время после тактового фронта.

        Пример :
        `set_output_delay 5 -rise -clock clk { d2 }`

            * Ожидается, что сигнал d2 должен быть стабильным через 5 нс после фронта clk.
            * Это ограничение для внутренней логики — вы должны успеть выдать сигнал вовремя.
3. virtual clock
    Virtual clock — это логический (виртуальный) сигнал тактирования, который не существует физически в проекте, но используется как ориентир при задании задержек на входах/выходах.


     Назначение виртуальных часов — дать тайминговому анализатору понять, когда ожидаются входы и когда должны появиться выходы, даже без наличия настоящих регистров или генераторов в проекте.

    т.е. это нужно для эмуляции не существующих блоков, чем-то похоже на затычки - моки в написании тестов для обычного программирования


4. Timing Exceptions

    Иногда определённые пути не должны анализироваться стандартным образом (например, они не являются критичными по времени). Для этого используют тайминг-исключения:



   1. set_false_path

        False path — это путь, который никогда не активируется в реальной работе схемы, и поэтому не должен проверяться в рамках анализа setup/hold таймингов.

        Команда указывает инструменту, что все пути между заданными стартовыми и конечными точками (или через указанные элементы) не должны анализироваться по setup/hold таймингам.

        Назначает путь как "ложный" — то есть тайминг на этом пути не проверяется.

        1. Синтаксис:
            set_false_path
            [-setup] [-hold]
            [-rise] [-fall]
            [-from ]
            [-to ]
            [-through ]

        2. пример синтаксиса : set_false_path -from [get_clocks {clk}] -to [get_ports {led}]

            * Указав в качестве источника регистр led:
                `set_false_path -from [get_registers {led*}] -to [get_ports {led}]`
            * Указав в качестве источника все регистры, тактируемые частотой clk:
                `set_false_path -from [get_clocks {clk}] -to [get_ports {led}]`
            * Указав в качестве источника все регистры, тактируемые любыми частотами проекта:
                `set_false_path -from [all_clocks] -to [get_ports {led}]`

        3. Отличие от set_clock_groups
            set_false_path — тайминг-исключение, влияет на report_exceptions
            set_clock_groups — глобальное отключение анализа между клоками, но не считается исключением


   2. set_max_delay / set_min_delay

        Позволяют жёстко задать максимальное или минимальное значение задержки на конкретном пути — переопределяя автоматические расчёты.

        Применение:

        * Комбинационные цепи
        * Асинхронные шины

        ```TCL
        set_max_delay 15 -from [get_ports a] -to [get_ports b]
        set_min_delay 2 -from [get_ports a] -to [get_ports b]
        ```



   3. set_multicycle_path

        Указывает, что данный путь занимает несколько тактовых циклов, и не должен проверяться за 1 цикл.

        `set_multicycle_path 3 -from [get_clocks clk] -to [get_clocks clk]`

         По умолчанию задержка проверяется как 1 тактовый цикл. Если вы знаете, что передача происходит, скажем, раз в 3 цикла — укажите это явно.
5. Set_clock_groups
    В отличие от вышеуказанных команд, set_clock_groups не считается тайминг-исключением, а представляет собой исключение путей между группами тактовых доменов.

    Применение:

    Разделение на независимые или взаимоисключающие тактовые домены, где тайминговый анализ между ними невозможен или не нужен.
    set_clock_groups -asynchronous \
      -group [get_clocks clk1] \
      -group [get_clocks clk2]

    > Это отключает анализ всех путей между clk1 и clk2, но не помечает их как исключения, поэтому они не попадают в отчёты об исключениях (`report_exceptions`).

6. Single Cycle and Multi Paths

    1. Single-Cycle Path (Однотактовый путь)

        По умолчанию, инструменты статического таймингового анализа (STA), такие как PrimeTime, считают, что все синхронные пути в проекте должны уложиться в один тактовый период.

        > Это означает, что данные, запущенные на одном фронте тактового сигнала, должны быть успешно захвачены на следующем фронте.

        ### Пример:
        DFF1 (launch flop) --> логика --> DFF2 (capture flop)

        Если период clk = 10 нс, то полный путь должен быть ≤ 10 нс (без учёта setup/hold времён и др. факторов).
    2. Multi-Cycle Path (Многотактовый путь)

        Многотактовые пути — это такие, которые по проектной логике требуют больше одного такта для передачи данных от одного регистра до другого.

        По этим путям нельзя применять стандартные однотактовые ограничения. Их необходимо явно объявлять.


        Timing Analysis: без корректного set_multicycle_path инструмент STA будет ошибочно считать путь нарушающим тайминг.

    3.  Команда `set_multicycle_path`
        set_multicycle_path <cycles> \
            [-setup] \
            [-hold] \
            [-from <objs>] \
            [-to <objs>] \
            [-start] [-end] \
            [-through <objs>]

        Эта команда говорит STA, что данный путь занимает больше одного такта для:

            * setup check — проверка "успеваемости" данных до захвата
            * hold check — проверка "устойчивости" данных после захвата

        Пример 1 — только Setup:

        set_multicycle_path -setup 2 -from [get_cells ff1b] -to [get_cells ff2d]

        > Теперь тайминговый анализатор будет ожидать, что данные от ff1b до ff2d захватятся через два такта, а не один.

            * Период = 10 нс → допускается до 20 нс задержки на path.
            * Hold-check при этом останется по умолчанию, то есть на том же такте (0-й цикл) — что может привести к ложным hold violations.


        Пример 2 — Setup + Hold:

        set_multicycle_path -hold 1 -from [get_cells ff1b] -to [get_cells ff2d]

        > Это смещает hold-проверку на предыдущий фронт, т.е. говорит, что путь действительно многотактовый и при этом устойчивость данных проверяется позже.

7. Multiple Clocks

     Проект может использовать несколько тактовых сигналов с разными частотами и формами сигнала. В этом случае необходимо учитывать особенности их взаимодействия в тайминговом анализе.

   1. Основные понятия:

        * LCM - это наименьший промежуток времени, через который две разные тактовые частоты снова совпадут по фронтам.
        * Разные частоты: если один клок работает на 50 МГц (20 нс), а другой на 75 МГц (13.33 нс), то они не синхронны.
        * Общая основа повторения фаз: статический анализ учитывает взаимодействие двух тактов по наименьшему общему кратному (LCM) периодов.

   2. Пример:
        clk1: период 20 нс (50 МГц)
        clk2: период 30 нс (33.3 МГц)
        LCM(20, 30) = 60 нс

        > Через каждые 60 нс фронты clk1 и clk2 совпадают, значит вся фаза взаимодействия повторяется каждые 60 нс.

   3. Поведение STA:

        * Инструмент будет моделировать все возможные взаимоотношения фронтов clk1 и clk2 в рамках LCM-интервала.
        * Это может порождать ложные ошибки по пути между асинхронными клоками, если они логически не связаны.

