# Конспект знаний по SDC и  XDC

## SDC

###  Конспект :
1. clk

    1. Start with Clock Period and Duty Cycle

        1. Clock period (a.k.a cycle-time )

        2. Duty Cycle = ratio = pulse width high time / pulse width low time

    2. create_clock

       1. create_clock –name “PHI1” –period 10 –waveform {0.0 5.0} [get_ports clk]

            * Создаёт такт "PHI1" с периодом 10 нс
            * Форма: подъём на 0.0 нс, спад на 5.0 нс (50% duty cycle)
            * Источник - порт clk (вероятно, входной порт чипа)

       2. create_clock -name "clk" -period 4 -waveform {2.0 4.0} {clkg1/Z clkg2/Z clkg3/Z

            * Создаёт тактовый сигнал с именем "clk" и периодом 4 нс
            * Форма сигнала (waveform): подъём на 2.0 нс, спад на 4.0 нс (т.е. duty cycle 50%)
            * Источники тактового сигнала - выходы (Z) трёх буферов clkg1, clkg2, clkg3

       3. create_clock –name "clk10" –period 10 –waveform {0.0 9.0} [get_pins U1/clkout]

            * Создаёт такт "clk10" с периодом 10 нс
            * Форма: подъём на 0.0 нс, спад на 9.0 нс (очень несимметричный, 90% duty cycle)
            * Источник - выходной пин clkout элемента U1

    3. `Clock Insertion Delay` (a.k.a. clock latency

        |Флаг	    |Что означает                                                   |
        |-----------|---------------------------------------------------------------|
        |-source    |	Это задержка от источника (PLL, порт) до начала clock tree  |
        |без -source|	Это задержка по clock tree до регистра                      |
        |-early     |	Используется в hold анализе (ранний приход такта)           |
        |-late      |	Используется в setup анализе (поздний приход такта)         |
        |-rise      |	Применяется только к фронту (rising edge)                   |
        |-fall      |	Применяется только к спаду (falling edge)                   |
        |-----------|---------------------------------------------------------------|

        1. `Source Latency` (Источник задержки)
            Это задержка от внешнего источника (например, порт clk или PLL) до входа в чип или до корня дерева тактовой сети внутри чипа.
            SDC-команда:

            ```tcl
            set_clock_latency -source <value> [get_clocks <clock_name>]
            ```

            Пример:

            ```tcl
            set_clock_latency -source 1.2 [get_clocks clk]

            ```

            Это значит, что сигнал clk доходит до начала clock tree за 1.2 нс.

        2. `Network Latency` (Clock Network Delay / Clock Tree Delay)

            Это задержка от корня clock tree до регистра внутри чипа, то есть сколько времени нужно, чтобы сигнал прошёл по clock tree (буферы, маршруты и т.д.).

            ```tcl
            set_clock_latency <value> [get_clocks <clock_name>]
            ```

            Пример:

            ```tcl
            set_clock_latency 0.8 [get_clocks clk]

            ```

            Значит, что от начала clock tree до регистра — 0.8 нс.

        3. `-rise / -fall`

            ``` TCL
            set_clock_latency 1.2 -rise [get_clocks CLK1]
            set_clock_latency 0.9 -fall [get_clocks CLK1]

            ```

            Устанавливает clock network latency (внутри кристалла):

            * 1.2 нс до фронта сигнала (rising edge)
            * 0.9 нс до спада сигнала (falling edge)
            * Эти значения используются в анализе тайминга, чтобы определить реальное время, когда тактовый импульс доходит до регистра.

            ```tcl
            set_clock_latency 0.8 -source -early [get_clocks CLK1]
            set_clock_latency 0.9 -source -late [get_clocks CLK1]

            ```
            Задаёт source latency — задержку от генератора сигнала (например, PLL) до начала clock tree.

            * -source: это именно source latency, а не задержка по clock tree.
            * -early и -late:
            * -early используется в hold анализе (самый ранний приход сигнала)
            * -late используется в setup анализе (самый поздний приход сигнала)

        4. Задержки влияют на расчёт setup/hold таймингов. Они определяют, когда реально приходит такт на регистр, и как сравнивать это с сигналами данных.

    4. Clock Uncertainty — это временной интервал, который учитывает
       1. джиттер (jitter) — нестабильность генерации (например, у PLL)
       2. неидеальность распространения по clock tree — сигнал может прийти к разным флип-флопам в немного разное время
       3. интерклоковая неопределённость (inter-clock skew/jitter) — между разными тактовыми доменами

                Команда: set_clock_uncertainty

            ```tcl
            set_clock_uncertainty -setup 0.65 [get_clocks CLK]
            set_clock_uncertainty -hold  0.45 [get_clocks CLK]

            ```
            *-setup: уменьшает время для setup анализа (усложняет тайминг)
            *-hold: увеличивает время для hold анализа (также усложняет тайминг)
            *-from / -to: можно указать конкретные тактовые домены (для междоменной неопределённости)

            Таким образом:

            * setup становится жёстче: данные должны прийти раньше.
            * hold становится тоже жёстче: данные не должны меняться слишком рано.

    5. Создание производного клока: `create_generated_clock`

        Для моделирования делителей/умножителей частоты, синхронных с основным клоком:

        ```tcl
        create_generated_clock -source FF1/CP -divide_by 2 -name CLK-OUT [get_pins FF1/Q]

        ```

        Пояснение:

        * -source FF1/CP: мастер-клок на входе CP регистра FF1
        * -divide_by 2: выходной клок будет в 2 раза медленнее
        * [get_pins FF1/Q]: создаётся на выходном пине Q регистра

        Пояснение параметров `create_generated_clock`

        | Параметр	        |Описание                                                       |
        |-------------------|---------------------------------------------------------------|
        |-source	        |Указывает мастер-клок (пин, откуда берётся исходный клок)      |
        |-divide_by N	    |Делит частоту клока на N                                       |
        |-multiply_by N	    |Умножает частоту клока на N                                    |
        |-duty_cycle %	    |Скважность сигнала в процентах                                 |
        |-edges	            |Явно задаёт фронты мастер-клока, формирующие новый клок        |
        |-invert	        |Инвертирует фазу клока                                         |
        |-edge_shift	    |Смещает фронты                                                 |
        |-------------------|---------------------------------------------------------------|

    6. `set_clock_transition`
       1. Эта команда задаёт скорость нарастания/спада фронтов клока (slew rate), то есть время перехода от 0 до 1 (и наоборот).

            * Работает только для ideal clocks
            * Не влияет на propagated clocks — для них переходы считаются по цепям
            * Если не указать set_clock_transition, то инструмент сам придумает переход (не всегда точный)
            * Помогает избежать заниженной/завышенной оценки тайминга

        Пример:

        ```tcl
        set_clock_transition 0.38 -rise [get_clocks CLK1]
        set_clock_transition 0.25 -fall [get_clocks CLK1]

        ```

        * Означает:

        * Время подъёма фронта (rise time) клока = 0.38 нс
        * Время спада фронта (fall time) клока = 0.25 нс
        * Применяется к клоку с именем CLK1
2. delay
    1. Input
        1. `set_input_delay – 1/2`

             1. Один тактовый домен

                 ```tcl
                 set_input_delay 4.3 -rise -clock CK2 {IN2}
                 set_input_delay 3.5 -fall -clock CK2 {IN2}

                 ```
                 IN2 — входной порт.
                 CK2 — тактовый сигнал с периодом 8 нс.
                 Сигнал IN2 может:
                 подняться (rising edge) через 4.3 нс после фронта CK2.
                 упасть (falling edge) через 3.5 нс после фронта CK2.

             2. Мультиклоковая задержка с -add_delay

                 ```tcl
                 set_input_delay 2.7 -clock CK1 -add_delay {IN1}
                 set_input_delay 4.2 -clock CK2 -add_delay {IN1}

                 ```

                 Вход IN1 может приходить от двух разных доменов: CK1 и CK2.
                 -add_delay указывает, что обе задержки добавляются, формируя связь между тактами.
                  Используется в асинхронных или мультиклоковых интерфейсах для описания перекрестных задержек.

         2. `set_input_delay – 2/2`

            Внешний модуль, генерирующий данные

            ```tcl
            set_input_delay 17 -rise -clock clk {d1}

            ```
            Внешний модуль (другой блок/микросхема) подаёт сигнал d1 через 17 нс после фронта clk.
            Эта задержка указывает, когда сигнал реально появится в текущем проекте, чтобы его можно было корректно захватить.




    3. `set_output_delay`
        Если предыдущие две команды были про внутренне взаимодействие эта про внешнее т.е. сколько сигналу идти относительно такта из внешнего бо







###  знания по (разминка) [этому ресурсу](https://kit-e.ru/synopsys-design-constraint-yazyk-zadaniya-vremennyh-ogranichenij-na-primere-altera-timequest-chast-1/):


####  команды
1.  `create_clock `
    Тактовые частоты описываются с помощью команды create_clock.
    Предположим, что у нас используется генератор с частотой 10 МГц. Тогда тактовая частота будет задаваться следующим образом:
    `create_clock -period 10MHz -name {clk} [get_ports {clk}]`

2.  `set_false_path`
    Иногда анализировать путь не нужно, потому что задержка на нём не важна для корректной работы схемы.
    Такой путь называют ложным путём (false path).
    Почему путь от регистра до светодиода led — ложный?
    Порт led — это выход на физический светодиод на плате. Мы просто подаём на него значение какого-то сигнала, например:

    ```verilog
    assign led = reg_value;

    ```
    И вот здесь важно:
    Мы не считываем этот сигнал обратно, не синхронизируем по нему другие логические блоки — он просто идёт "в никуда".

    Поэтому:

    * Сколько бы ни шёл сигнал до led — это не влияет на логику работы схемы.
    * Анализировать такой путь — бессмысленно, но компилятор всё равно будет тратить ресурсы и, возможно, выдаст ненужные предупреждения
        пример синтаксиса : set_false_path -from [get_clocks {clk}] -to [get_ports {led}]
    1. Указав в качестве источника регистр led:
        `set_false_path -from [get_registers {led*}] -to [get_ports {led}]`
    2. Указав в качестве источника все регистры, тактируемые частотой clk:
        `set_false_path -from [get_clocks {clk}] -to [get_ports {led}]`
    3. Указав в качестве источника все регистры, тактируемые любыми частотами проекта:
       `set_false_path -from [all_clocks] -to [get_ports {led}]`
3. clock uncertainty
        команды, связанные с clock uncertainty, используются для задания временной нестабильности тактового сигнала
        пример: `derive_clock_uncertainty` - берет дефолтный джиттер, что бы его поменять можно использовать `set_clock_uncertainty`
