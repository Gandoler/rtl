# Конспект знаний по SDC и  XDC

## SDC

###  Конспект :
1. clk

   1. Start with Clock Period and Duty Cycle
         1. Clock period (a.k.a cycle-time )
         2. Duty Cycle = ratio = pulse width high time / pulse width low time

   2. create_clock
          1. create_clock –name “PHI1” –period 10 –waveform {0.0 5.0} [get_ports clk]

                * Создаёт такт "PHI1" с периодом 10 нс
                * Форма: подъём на 0.0 нс, спад на 5.0 нс (50% duty cycle)
                * Источник - порт clk (вероятно, входной порт чипа)
          2. create_clock -name "clk" -period 4 -waveform {2.0 4.0} {clkg1/Z clkg2/Z clkg3/Z}
                * Создаёт тактовый сигнал с именем "clk" и периодом 4 нс
                * Форма сигнала (waveform): подъём на 2.0 нс, спад на 4.0 нс (т.е. duty cycle 50%)
                * Источники тактового сигнала - выходы (Z) трёх буферов clkg1, clkg2, clkg3
          3. create_clock –name "clk10" –period 10 –waveform {0.0 9.0} [get_pins U1/clkout]
                * Создаёт такт "clk10" с периодом 10 нс
                * Форма: подъём на 0.0 нс, спад на 9.0 нс (очень несимметричный, 90% duty cycle)
                * Источник - выходной пин clkout элемента U1



    3. `Clock Insertion Delay` (a.k.a. clock latency)


        |Флаг	    |Что означает                                                   |
        |-----------|---------------------------------------------------------------|
        |-source    |	Это задержка от источника (PLL, порт) до начала clock tree  |
        |без -source|	Это задержка по clock tree до регистра                      |
        |-early     |	Используется в hold анализе (ранний приход такта)           |
        |-late      |	Используется в setup анализе (поздний приход такта)         |
        |-rise      |	Применяется только к фронту (rising edge)                   |
        |-fall      |	Применяется только к спаду (falling edge)                   |


   4. `Source Latency` (Источник задержки)
            Это задержка от внешнего источника (например, порт clk или PLL) до входа в чип
            или до корня дерева тактовой сети внутри чипа.
            SDC-команда:

            ```tcl
            set_clock_latency -source <value> [get_clocks <clock_name>]
            ```

            Пример:

            ```tcl
            set_clock_latency -source 1.2 [get_clocks clk]

            ```

            Это значит, что сигнал clk доходит до начала clock tree за 1.2 нс.

        1. `Network Latency` (Clock Network Delay / Clock Tree Delay)

            Это задержка от корня clock tree до регистра внутри чипа,
            то есть сколько времени нужно, чтобы сигнал прошёл по clock tree (буферы, маршруты и т.д.).

            ```tcl
            set_clock_latency <value> [get_clocks <clock_name>]
            ```

            Пример:

            ```tcl
            set_clock_latency 0.8 [get_clocks clk]

            ```

            Значит, что от начала clock tree до регистра — 0.8 нс.

        2. `-rise / -fall`

            ``` TCL
            set_clock_latency 1.2 -rise [get_clocks CLK1]
            set_clock_latency 0.9 -fall [get_clocks CLK1]

            ```

            Устанавливает clock network latency (внутри кристалла):

            * 1.2 нс до фронта сигнала (rising edge)
            * 0.9 нс до спада сигнала (falling edge)
            * Эти значения используются в анализе тайминга, чтобы определить реальное время, когда тактовый импульс доходит до регистра.

            ```tcl
            set_clock_latency 0.8 -source -early [get_clocks CLK1]
            set_clock_latency 0.9 -source -late [get_clocks CLK1]

            ```
            Задаёт source latency — задержку от генератора сигнала (например, PLL) до начала clock tree.

            * -source: это именно source latency, а не задержка по clock tree.
            * -early и -late:
            * -early используется в hold анализе (самый ранний приход сигнала)
            * -late используется в setup анализе (самый поздний приход сигнала)

        3. Задержки влияют на расчёт setup/hold таймингов. Они определяют, когда реально приходит такт на регистр, 
        и как сравнивать это с сигналами данных.

    5. Clock Uncertainty — это временной интервал, который учитывает
       1. джиттер (jitter) — нестабильность генерации (например, у PLL)
       2. неидеальность распространения по clock tree — сигнал может прийти к разным флип-флопам в немного разное время
       3. интерклоковая неопределённость (inter-clock skew/jitter) — между разными тактовыми доменами

                Команда: set_clock_uncertainty

            ```tcl
            set_clock_uncertainty -setup 0.65 [get_clocks CLK]
            set_clock_uncertainty -hold  0.45 [get_clocks CLK]

            ```
            *-setup: уменьшает время для setup анализа (усложняет тайминг)
            *-hold: увеличивает время для hold анализа (также усложняет тайминг)
            *-from / -to: можно указать конкретные тактовые домены (для междоменной неопределённости)

            Таким образом:

            * setup становится жёстче: данные должны прийти раньше.
            * hold становится тоже жёстче: данные не должны меняться слишком рано.

    6. Создание производного клока: `create_generated_clock`

        Для моделирования делителей/умножителей частоты, синхронных с основным клоком:

        ```tcl
        create_generated_clock -source FF1/CP -divide_by 2 -name CLK-OUT [get_pins FF1/Q]

        ```

        Пояснение:

        * -source FF1/CP: мастер-клок на входе CP регистра FF1
        * -divide_by 2: выходной клок будет в 2 раза медленнее
        * [get_pins FF1/Q]: создаётся на выходном пине Q регистра

        Пояснение параметров `create_generated_clock`

        | Параметр	        |Описание                                                       |
        |-------------------|---------------------------------------------------------------|
        |-source	        |Указывает мастер-клок (пин, откуда берётся исходный клок)      |
        |-divide_by N	    |Делит частоту клока на N                                       |
        |-multiply_by N	    |Умножает частоту клока на N                                    |
        |-duty_cycle %	    |Скважность сигнала в процентах                                 |
        |-edges	            |Явно задаёт фронты мастер-клока, формирующие новый клок        |
        |-invert	        |Инвертирует фазу клока                                         |
        |-edge_shift	    |Смещает фронты                                                 |


    7. `set_clock_transition`
       1. Эта команда задаёт скорость нарастания/спада фронтов клока (slew rate), то есть время перехода от 0 до 1 (и наоборот).

            * Работает только для ideal clocks
            * Не влияет на propagated clocks — для них переходы считаются по цепям
            * Если не указать set_clock_transition, то инструмент сам придумает переход (не всегда точный)
            * Помогает избежать заниженной/завышенной оценки тайминга

        Пример:

        ```tcl
        set_clock_transition 0.38 -rise [get_clocks CLK1]
        set_clock_transition 0.25 -fall [get_clocks CLK1]

        ```

        * Означает:

        * Время подъёма фронта (rise time) клока = 0.38 нс
        * Время спада фронта (fall time) клока = 0.25 нс
        * Применяется к клоку с именем CLK1
2. delay
    1. Input
        1. `set_input_delay – 1/2`

             1. Один тактовый домен

                 ```tcl
                 set_input_delay 4.3 -rise -clock CK2 {IN2}
                 set_input_delay 3.5 -fall -clock CK2 {IN2}

                 ```
                 IN2 — входной порт.
                 CK2 — тактовый сигнал с периодом 8 нс.
                 Сигнал IN2 может:
                 подняться (rising edge) через 4.3 нс после фронта CK2.
                 упасть (falling edge) через 3.5 нс после фронта CK2.

             2. Мультиклоковая задержка с -add_delay

                 ```tcl
                 set_input_delay 2.7 -clock CK1 -add_delay {IN1}
                 set_input_delay 4.2 -clock CK2 -add_delay {IN1}

                 ```

                 Вход IN1 может приходить от двух разных доменов: CK1 и CK2.
                 -add_delay указывает, что обе задержки добавляются, формируя связь между тактами.
                  Используется в асинхронных или мультиклоковых интерфейсах для описания перекрестных задержек.

        2. `set_input_delay – 2/2`

            Внешний модуль, генерирующий данные

            ```tcl
            set_input_delay 17 -rise -clock clk {d1}

            ```
            Внешний модуль (другой блок/микросхема) подаёт сигнал d1 через 17 нс после фронта clk.
            Эта задержка указывает, когда сигнал реально появится в текущем проекте, чтобы его можно было корректно захватить.
        3. Пояснение параметров

            | Параметр                    | Описание                                                   |
            | --------------------------- | ---------------------------------------------------------- |
            | -clock <clk>              | Указывает, к какому такту относится задержка               |
            | -rise / -fall           | Задержка для переднего или заднего фронта данных           |
            | -add_delay                | Учитывать дополнительные задержки между тактовыми доменами |
            | -max / -min             | Задержки для worst-case / best-case анализа                |
            | -network_latency_included | Учитывать ли задержку проводников                          |
            | -source_latency_included  | Учитывать ли задержку источника сигнала                    |




    1. `set_output_delay`
        Назначение

            * Указывает, сколько времени у вашего проекта есть, чтобы передать данные на внешний модуль.
            * То есть внешний модуль будет ожидать данные через указанное время после тактового фронта.

        Пример :
        `set_output_delay 5 -rise -clock clk { d2 }`

            * Ожидается, что сигнал d2 должен быть стабильным через 5 нс после фронта clk.
            * Это ограничение для внутренней логики — вы должны успеть выдать сигнал вовремя.
3. virtual clock
    Virtual clock — это логический (виртуальный) сигнал тактирования, который не существует физически в проекте, но используется как ориентир при задании задержек на входах/выходах.


     Назначение виртуальных часов — дать тайминговому анализатору понять, когда ожидаются входы и когда должны появиться выходы, даже без наличия настоящих регистров или генераторов в проекте.

    т.е. это нужно для эмуляции не существующих блоков, чем-то похоже на затычки - моки в написании тестов для обычного программирования


4. Timing Exceptions

    Иногда определённые пути не должны анализироваться стандартным образом (например, они не являются критичными по времени). Для этого используют тайминг-исключения:



   1. set_false_path

        False path — это путь, который никогда не активируется в реальной работе схемы, и поэтому не должен проверяться в рамках анализа setup/hold таймингов.

        Команда указывает инструменту, что все пути между заданными стартовыми и конечными точками (или через указанные элементы) не должны анализироваться по setup/hold таймингам.

        Назначает путь как "ложный" — то есть тайминг на этом пути не проверяется.

        1. Синтаксис:
            set_false_path
            [-setup] [-hold]
            [-rise] [-fall]
            [-from ]
            [-to ]
            [-through ]

        2. пример синтаксиса : set_false_path -from [get_clocks {clk}] -to [get_ports {led}]

            * Указав в качестве источника регистр led:
                `set_false_path -from [get_registers {led*}] -to [get_ports {led}]`
            * Указав в качестве источника все регистры, тактируемые частотой clk:
                `set_false_path -from [get_clocks {clk}] -to [get_ports {led}]`
            * Указав в качестве источника все регистры, тактируемые любыми частотами проекта:
                `set_false_path -from [all_clocks] -to [get_ports {led}]`

        3. Отличие от set_clock_groups
            set_false_path — тайминг-исключение, влияет на report_exceptions
            set_clock_groups — глобальное отключение анализа между клоками, но не считается исключением


   2. set_max_delay / set_min_delay

        Команда set_max_delay используется в статическом тайминговом анализе (STA) для переопределения стандартных ограничений на максимальную задержку между двумя точками пути.

        По умолчанию инструменты STA считают, что данные между регистрами должны быть переданы за один такт (или многотактно при set_multicycle_path), и максимальная задержка пути определяется исходя из периода клока.

        1. Команда set_max_delay позволяет:

            * Жёстко ограничить максимальную задержку между двумя точками
            * Указать допустимую задержку меньшую или большую стандартной
            * Использовать это ограничение даже при отсутствии clocks (например, на асинхронных путях)

        2. Синтаксис
            set_max_delay <значение_в_нс>
            [-from ]
            [-to ]
            [-through <netlist_elements>]
            [-rise] [-fall]

         3. Примеры

            1. Пример 1: конкретные start и end
            set_max_delay 15.0 -from {ffa ffb} -to {ffe}

            > Все пути от ffa и ffb до ffe должны иметь задержку меньше 15 нс.

            2.  Пример 2: глобально на все пути, заканчивающиеся в домене CK2
            set_max_delay 8.5 -to [get_clocks CK2]

            > Все пути, заканчивающиеся во флип-флопах под тактом CK2, должны иметь задержку не более 8.5 нс.

         4. Поведение

            * Заменяет стандартные задержки на setup-анализе
            * Устанавливает конкретный порог тайминга вместо автоматических вычислений
            * Может использоваться для:

              * Задания ограничений между асинхронными или квазисинхронными доменами
              * Сжатия задержек по критически важным интерфейсам
              * Ограничения задержек на IO-портах




   3. set_multicycle_path

        Указывает, что данный путь занимает несколько тактовых циклов, и не должен проверяться за 1 цикл.

        `set_multicycle_path 3 -from [get_clocks clk] -to [get_clocks clk]`

         По умолчанию задержка проверяется как 1 тактовый цикл. Если вы знаете, что передача происходит, скажем, раз в 3 цикла — укажите это явно.
5. Set_clock_groups
    В отличие от вышеуказанных команд, set_clock_groups не считается тайминг-исключением, а представляет собой исключение путей между группами тактовых доменов.

    Применение:

    Разделение на независимые или взаимоисключающие тактовые домены, где тайминговый анализ между ними невозможен или не нужен.
    set_clock_groups -asynchronous \
      -group [get_clocks clk1] \
      -group [get_clocks clk2]

    > Это отключает анализ всех путей между clk1 и clk2, но не помечает их как исключения, поэтому они не попадают в отчёты об исключениях (`report_exceptions`).

6. Single Cycle and Multi Paths

    1. Single-Cycle Path (Однотактовый путь)

        По умолчанию, инструменты статического таймингового анализа (STA), такие как PrimeTime, считают, что все синхронные пути в проекте должны уложиться в один тактовый период.

        > Это означает, что данные, запущенные на одном фронте тактового сигнала, должны быть успешно захвачены на следующем фронте.

        ### Пример:
        DFF1 (launch flop) --> логика --> DFF2 (capture flop)

        Если период clk = 10 нс, то полный путь должен быть ≤ 10 нс (без учёта setup/hold времён и др. факторов).
    2. Multi-Cycle Path (Многотактовый путь)

        Многотактовые пути — это такие, которые по проектной логике требуют больше одного такта для передачи данных от одного регистра до другого.

        По этим путям нельзя применять стандартные однотактовые ограничения. Их необходимо явно объявлять.


        Timing Analysis: без корректного set_multicycle_path инструмент STA будет ошибочно считать путь нарушающим тайминг.

    3.  Команда `set_multicycle_path`
        set_multicycle_path <cycles> \
            [-setup] \
            [-hold] \
            [-from <objs>] \
            [-to <objs>] \
            [-start] [-end] \
            [-through <objs>]

        Эта команда говорит STA, что данный путь занимает больше одного такта для:

            * setup check — проверка "успеваемости" данных до захвата
            * hold check — проверка "устойчивости" данных после захвата

        Пример 1 — только Setup:

        set_multicycle_path -setup 2 -from [get_cells ff1b] -to [get_cells ff2d]

        > Теперь тайминговый анализатор будет ожидать, что данные от ff1b до ff2d захватятся через два такта, а не один.

            * Период = 10 нс → допускается до 20 нс задержки на path.
            * Hold-check при этом останется по умолчанию, то есть на том же такте (0-й цикл) — что может привести к ложным hold violations.


        Пример 2 — Setup + Hold:

        set_multicycle_path -hold 1 -from [get_cells ff1b] -to [get_cells ff2d]

        > Это смещает hold-проверку на предыдущий фронт, т.е. говорит, что путь действительно многотактовый и при этом устойчивость данных проверяется позже.

7. Multiple Clocks

     Проект может использовать несколько тактовых сигналов с разными частотами и формами сигнала. В этом случае необходимо учитывать особенности их взаимодействия в тайминговом анализе.

   1. Основные понятия:

        * LCM - это наименьший промежуток времени, через который две разные тактовые частоты снова совпадут по фронтам.
        * Разные частоты: если один клок работает на 50 МГц (20 нс), а другой на 75 МГц (13.33 нс), то они не синхронны.
        * Общая основа повторения фаз: статический анализ учитывает взаимодействие двух тактов по наименьшему общему кратному (LCM) периодов.

   2. Пример:
        clk1: период 20 нс (50 МГц)
        clk2: период 30 нс (33.3 МГц)
        LCM(20, 30) = 60 нс

        > Через каждые 60 нс фронты clk1 и clk2 совпадают, значит вся фаза взаимодействия повторяется каждые 60 нс.

   3. Поведение STA:

        * Инструмент будет моделировать все возможные взаимоотношения фронтов clk1 и clk2 в рамках LCM-интервала.
        * Это может порождать ложные ошибки по пути между асинхронными клоками, если они логически не связаны.

8. Priority of the Commands
   1. Приоритет типов временных исключений

            Когда для одного и того же пути указано несколько исключений, применяется наиболее приоритетное из них. Приоритет команд (от самого высокого к низкому):

            set_false_path > set_max_delay / set_min_delay > set_multicycle_path

        > Это значит, что если для одного и того же пути заданы, например, set_false_path и set_max_delay, будет действовать set_false_path.
   2. Правило специфичности (Rule of Specificity)

        Если один и тот же тип исключения (`set_max_delay`, set_false_path и т.п.) задан несколько раз, но с разной специфичностью путей, приоритет будет у наиболее специфичного исключения.

        Примеры:
            * set_max_delay 12 -from [get_clocks CLK1]                 ; общий путь от CLK1
            * set_max_delay 15 -from [get_clocks CLK1] -to [get_clocks CLK2] ; более специфичный путь от CLK1 до CLK2

        > Будет применён set_max_delay 15, так как путь более конкретно указан (от одного клока до другого).\
   3. Приоритет объектов

        При одинаковом типе команды (например, `set_false_path`) исключения, заданные на более конкретные объекты, имеют больший приоритет.

        Пример:
            * set_false_path -from [get_clocks clk1]
            * set_false_path -from [get_pins a_reg/ck]

        > Второй вариант (через конкретный пин регистра) имеет более высокий приоритет, чем общий set_false_path от клока.

   4. Приоритет опций `-from`, `-to`, `-through`

        Порядок приоритета при указании путей по опциям -from, -to, -through (от самого специфичного к менее специфичному):
            * -from pin, -rise_from pin, -fall_from pin
            * -to pin, -rise_to pin, -fall_to pin
            * -through, -rise_through, -fall_through
            * -from clock, -rise_from clock, -fall_from clock
            * -to clock, -rise_to clock, -fall_to clock

        > Это означает, что исключение, заданное с -from [get_pins ...], будет иметь больший приоритет, чем -from [get_clocks ...].
9. Основы проверки корректности статического таймингового анализа (STA)

  1. Базовые требования для корректной работы STA

        Чтобы инструменты статического таймингового анализа могли адекватно оценивать задержки путей, необходимо:

        * Полная и корректная схема (синтаксически и логически завершённый дизайн).
        * Полный набор тайминговых ограничений (constraints).
        * Реалистичные значения ограничений.

        Важно:
        STA-анализ критически важен как для этапа синтеза, так и для последующих этапов реализации и оптимизации.
        Качество STA напрямую зависит от качества введённых ограничений.

  2.  Полнота ограничений (Complete Constraints)

        Для полноценного анализа должны быть покрыты все критические типы путей:

        * Путь от триггера до триггера (flip-flop to flip-flop)
        * Путь от внешнего входа до триггера (input to flip-flop)
        * Путь от триггера до внешнего выхода (flip-flop to output)
        * Чисто комбинационные пути (combinational paths)

        Это означает:

        * Для всех триггеров должен быть задан тактовый сигнал через create_clock.
        * Для всех входов должен быть указан set_input_delay относительно тактового сигнала или времени прихода данных.
        * Для всех выходов должен быть задан set_output_delay относительно тактового сигнала или времени требований.
        * Для комбинационных путей можно задать максимальные задержки (`set_max_delay`), если они не ограничены входами/выходами.

  3.  Реалистичные ограничения (Realistic Constraints)

        Ограничения считаются реалистичными, если:

        * Существует положительное время выполнения, при котором путь способен удовлетворить требованиям по задержке.
        * Установлен положительный required time.

        Типичные проблемы:

        * Нереалистичные ограничения на входах/выходах, которые приводят к:

          * required time < 0 — путь заведомо не может быть выполнен.
          * Предупреждения от STA-инструмента:

            * CCD_CLK_UNC3, CCD_MISC_MSC11 — отсутствующая неопределённость тактового сигнала.
            * CCD_IO_IDL5, CCD_IO_ODL5 — input/output delay больше 80% от периода такта.
            * sdc_input_delay_ratio, sdc_output_delay_ratio — превышение допустимого отношения задержки.
            * CCD_DGN_CMB2 — задан set_min_delay > set_max_delay.

  4.  Полный набор ограничений — не всегда просто

         STA-инструменты допускают предположения, если ограничения отсутствуют:

        * Отсутствующая неопределённость (uncertainty) — предполагается 0.
        * Отсутствие задержек ввода/вывода — тоже предполагается 0.
        * Отсутствие задержки вывода может привести к отсутствию анализа на пути "триггер → выход".
        * Конфликтующие set\_case\_analysis — неправильное распространение условий может нарушить анализ.
        * Некоторые части схемы могут быть проанализированы некорректно.


10. SDC Modes и Multimode SDC

      1. Основные режимы SDC

        Хорошей практикой считается использовать минимальное количество SDC-файлов. Однако для корректного покрытия всех аспектов тайминга необходимо понимать, что существуют два основных режима SDC:

        1. Functional Mode SDC

            * Используется для синтеза основной (функциональной) логики чипа.
            * Описывает обычное поведение устройства.
            * Обычно содержит:

                * Основные тайминговые ограничения (`create_clock`, set_input_delay, set_output_delay, и т.д.).
                * Исключения для функционального режима (`set_false_path`, set_multicycle_path и др.).

        2. Test Mode SDC

            * Используется при синтезе режима тестирования (DFT – Design for Test).
            * Этот режим активируется логикой сканирования или BIST (Built-In Self Test).
            * Может включать другие клоки и ограничения, отличные от функционального режима.

      2. Классификация по фазам построения тактовой сети
       SDC-файлы также классифицируются по стадии построения clock tree:

         1. Pre-CTS (до Clock Tree Synthesis)

            * Используются, когда клоки рассматриваются как идеальные (без задержек).
            * Ограничения указываются в предположении идеального распределения сигнала клока.
            * Полезно для раннего анализа setup/hold таймингов до построения дерева клока.

         2.  Post-CTS (после Clock Tree Synthesis)

            * Используются после того, как построено дерево клока, и реальные задержки вставки клока известны.
            * Тайминговый анализ выполняется с учётом этих реальных задержек.
            * Даёт более точную картину setup/hold нарушений.

  11. Multimode SDC

        1. Mode types:

            * functional (основной режим работы),
            * test (сканирование, BIST),
            * low-power,
            * fast/slow corner,
            * и др.

        2. Реализация многорежимной поддержки

            * Для каждого режима можно создать отдельный SDC-файл.
            * Обычно также разделяют по типу проверки:

              * Setup analysis
              * Hold analysis

         3. Подходы к объединению режимов

           1. set_case_analysis

                * Используется для управления статическими значениями управляющих сигналов.
                * Например, можно "заморозить" сигнал test\_mode в 0 или 1 для активации нужной части логики.

           2. Виртуальные клоки (`create_clock -name virtual_clk`)

                * Применяются для задания различных сценариев с разными источниками тактирования.
                * Между виртуальными и реальными клоками часто задаются set_false_path, чтобы исключить ложные пути при анализе.


          4. Практика: Один файл на каждую проверку

        Для каждого сочетания режимов и фаз разумно иметь отдельный SDC-файл:

        | Назначение  | Режим      | Фаза     | Файл                     |
        | ----------- | ---------- | -------- | ------------------------ |
        | Setup Check | Functional | Pre-CTS  | func_setup_pre_cts.sdc |
        | Hold Check  | Functional | Post-CTS | func_hold_post_cts.sdc |
        | Setup Check | Test       | Pre-CTS  | test_setup_pre_cts.sdc |
        | Hold Check  | Test       | Post-CTS | test_hold_post_cts.sdc |
